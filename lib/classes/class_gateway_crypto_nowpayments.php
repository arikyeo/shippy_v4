<?php

require_once(realpath(__DIR__ . '/../vendor/autoload.php'));
require_once(realpath(__DIR__ . '/class_main.php'));

use GuzzleHttp\Client;
use GuzzleHttp\Exception\RequestException;


/* 
CREATE TABLE `wallet_topups` (
 `id` int(11) NOT NULL AUTO_INCREMENT,
 `txn-hash` varchar(128) NOT NULL COMMENT 'Transaction hash (for internal reference)',
 `txn-hash_user` varchar(128) DEFAULT NULL COMMENT 'User hash attributed to the transaction',
 `txn-status` varchar(255) NOT NULL,
 `txn-status_text` mediumtext NOT NULL,
 `txn-amt_shiptokens` float NOT NULL DEFAULT 0 COMMENT 'Amt in shiptokens (virtual token currency)',
 `txn-amt_USD_cents` decimal(10,2) NOT NULL,
 `txn-time_created` timestamp NOT NULL DEFAULT current_timestamp(),
 `txn-time_updated` timestamp NOT NULL DEFAULT current_timestamp() ON UPDATE current_timestamp(),
 `txn-gateway` varchar(128) NOT NULL,
 `txn-gateway_response` longtext NOT NULL CHECK (json_valid(`txn-gateway_response`)),
 `txn-gateway_params` longtext DEFAULT NULL COMMENT 'Storage for params generated by gateway for retrieval (flexible)',
 `txn-comments` text DEFAULT NULL COMMENT 'Comments/remarks (if any)',
 PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
*/

class class_gateway_crypto_NOWpayments extends class_main {
	private $session_api_key;

	// private $API_key = 'R8R3PJM-5Z8M7V8-G7AP7J3-1R966PF';
	// private $API_endpoint = 'https://api.nowpayments.io/v1/';

	private $API_key = NOWPAYMENTS_API_KEY;
	private $API_endpoint = NOWPAYMENTS_API_ENDPOINT;

	public function __construct() {
		if (!$this->gateway_NOWPayments_check_api()) {
			die("Failed to connect to NOWPayments API");
		}

		parent::__construct();

		// $this->session_jwt_token = $this->NOWPayments_get_jwt_token();
	}

	public function __destruct() {
		parent::__destruct();
	}

	public function get_binance_ticker_price() {
		/*
			API Format outputs like so:

			[
							{
											"symbol": "ETHBTC",
											"price": "0.04732000"
							},
							{
											"symbol": "LTCBTC",
											"price": "0.00130900"
							},
							....
			]
			*/


		$client = new Client([
			'base_uri' => 'https://api.binance.com',
		]);

		try {
			$response = $client->request('GET', '/api/v3/ticker/price');

			if ($response->getStatusCode() == 200) {
				$json_response = json_decode($response->getBody(), true);
				return $json_response;
			} else {
				return false;
			}
		} catch (RequestException $e) {
			echo "Error: " . $e->getMessage();
		}
	}

	public function get_bitstamp_ticker_price() {
		/*
			API Format outputs like so:

			[
							{
											"timestamp": "1715598054",
											"open": "61446",
											"high": "63262",
											"low": "60758",
											"last": "62616",
											"volume": "1065.14916852",
											"vwap": "61804",
											"bid": "62618",
											"ask": "62622",
											"side": "1",
											"open_24": "61150",
											"percent_change_24": "2.40",
											"pair": "BTC/USD"
							},
							{
											"timestamp": "1715598054",
											"open": "57083",
											"high": "58668",
											"low": "56427",
											"last": "58101",
											"volume": "136.18164890",
											"vwap": "57384",
											"bid": "58096",
											"ask": "58100",
											"side": "0",
											"open_24": "56793",
											"percent_change_24": "2.30",
											"pair": "BTC/EUR"
							},
							...
			]
			*/

		$client = new Client([
			'base_uri' => 'https://www.bitstamp.net',
		]);

		try {
			$response = $client->request('GET', '/api/v2/ticker/');

			if ($response->getStatusCode() == 200) {
				$json_response = json_decode($response->getBody(), true);
				return $json_response;
			} else {
				return false;
			}
		} catch (RequestException $e) {
			echo "Error: " . $e->getMessage();
		}
	}

	// Checks if NOWPayments API is up
	public function gateway_NOWPayments_check_api() {
		$client = new Client([
			'base_uri' => $this->API_endpoint,
		]);

		try {
			$response = $client->request('GET', 'status');

			if ($response->getStatusCode() == 200) {
				$json_response = json_decode($response->getBody(), true);

				if ($json_response['message'] == "OK") {
					return true;
				}
			} else {
				return false;
			}
		} catch (RequestException $e) {
			echo "Error: " . $e->getMessage();
		}
	}

	private function gateway_NOWPayments_get_jwt_token() {
		$client = new Client([
			'base_uri' => $this->API_endpoint,
		]);

		try {
			$response = $client->request('POST', 'auth', [
				'json'    => [
					'email'    => 'bendoverhere9669@gmail.com',
					'password' => 'Weewee88!'
				],
				'headers' => [
					'Content-Type' => 'application/json',
				]
			]);

			if ($response->getStatusCode() == 200) {
				$json_response = json_decode($response->getBody(), true);
				return $json_response['token'];
			} else {
				return false;
			}
		} catch (RequestException $e) {
			echo "Error: " . $e->getMessage();
		}
	}

	public function gateway_NOWPayments_get_available_currencies() {
		/* Data looks like so:
			"currencies": [
							{
											"min_amount": 3.4742826,
											"max_amount": 3024.26096169,
											"currency": "cake"
							},
							{
											"min_amount": 8.5386651,
											"max_amount": 2977.665358,
											"currency": "usdcmatic"
							},
							...
			] */

		$client = new Client([
			'base_uri' => $this->API_endpoint,
		]);

		try {
			$response = $client->request('GET', 'currencies?fixed_rate=true', [
				'headers' => [
					'x-api-key' => $this->API_key,
				]
			]);

			if ($response->getStatusCode() == 200) {
				return json_decode($response->getBody(), true)["currencies"];
			} else {
				return false;
			}
		} catch (RequestException $e) {
			echo "Error: " . $e->getMessage();
		}
	}

	public function gateway_NOWPayments_get_available_currencies_detail() {
		/* Data looks like so:
							"currencies": [
											{
															"id": 203,
															"code": "1INCH",
															"name": "1inch Network",
															"enable": true,
															"wallet_regex": "^(0x)[0-9A-Fa-f]{40}$",
															"priority": 168,
															"extra_id_exists": false,
															"extra_id_regex": null,
															"logo_url": "/images/coins/1inch.svg",
															"track": true,
															"cg_id": "1inch",
															"is_maxlimit": false,
															"network": "eth",
															"smart_contract": null,
															"network_precision": null,
															"explorer_link_hash": null,
															"precision": 8,
															"ticker": "1inch",
															"is_defi": false,
															"is_popular": false,
															"is_stable": false,
															"available_for_to_conversion": false,
															"trust_wallet_id": null
											},
											{
															"id": 204,
															"code": "1INCHBSC",
															"name": "1Inch Network (BSC)",
															"enable": true,
															"wallet_regex": "^(0x)[0-9A-Fa-f]{40}$",
															"priority": 171,
															"extra_id_exists": false,
															"extra_id_regex": null,
															"logo_url": "/images/coins/1inchbsc.svg",
															"track": true,
															"cg_id": "1inch",
															"is_maxlimit": false,
															"network": "bsc",
															"smart_contract": null,
															"network_precision": null,
															"explorer_link_hash": null,
															"precision": 8,
															"ticker": "1inch",
															"is_defi": false,
															"is_popular": false,
															"is_stable": false,
															"available_for_to_conversion": false,
															"trust_wallet_id": null
											},
											...
			] */

		$client = new Client();

		try {
			$response = $client->request('GET', $this->API_endpoint . "full-currencies", [
				'headers'         => [
					'x-api-key' => $this->API_key,
				],
				'allow_redirects' => true,
			]);

			if ($response->getStatusCode() == 200) {
				return json_decode($response->getBody(), true)["currencies"];
			} else {
				return false;
			}
		} catch (RequestException $e) {
			echo "Error: " . $e->getMessage();
		}
	}

	public function gateway_NOWPayments_create_order($order_amt_usd, $order_currency, $order_id, $order_description, $fiat_currency = "usd") {

		// Order details params
		$order_details = array();
		$order_details["price_amount"] = $order_amt_usd;
		$order_details["price_currency"] = $fiat_currency;
		$order_details["pay_currency"] = $order_currency;
		// $order_details["ipn_callback_url"] = "https://nowpayments.io";
		$order_details["order_id"] = $order_id;
		$order_details["order_description"] = $order_description;
		$order_details["is_fee_paid_by_user"] = true;

		// List of available cases:
		// success(default) - finished payment example.
		// common - common payment
		// failed - failed payment example.
		// partially_paid - partially_paid payment example.
		
		// $order_details["case"] = "partially_paid"; # sandbox
		$order_details["case"] = "success"; # sandbox

		$client = new Client([
			'base_uri' => $this->API_endpoint,
		]);

		try {
			$response = $client->request('POST', 'payment', [
				'json'    => $order_details,
				'headers' => [
					'x-api-key'    => $this->API_key,
					'Content-Type' => 'application/json',
				]
			]);

			if ($response->getStatusCode() == 201) {
				return json_decode($response->getBody(), true);
			} else {
				return false;
			}
		} catch (RequestException $e) {
			echo "Error: " . $e->getMessage();
		}

		/* Data looks like so:

			{
							"payment_id": "5300799617",
							"payment_status": "waiting",
							"pay_address": "MHz8mvMvqGbeXWcotBAviYu3iWoT4EkLET",
							"price_amount": 3999.5,
							"price_currency": "usd",
							"pay_amount": 49.93361491,
							"amount_received": 4002.818927,
							"pay_currency": "ltc",
							"order_id": "RGDBP-21314",
							"order_description": "Apple Macbook Pro 2019 x 1",
							"payin_extra_id": null,
							"ipn_callback_url": null,
							"created_at": "2024-05-13T15:03:57.864Z",
							"updated_at": "2024-05-13T15:03:57.864Z",
							"purchase_id": "4544389626",
							"smart_contract": null,
							"network": "ltc",
							"network_precision": null,
							"time_limit": null,
							"burning_percent": null,
							"expiration_estimate_date": "2024-05-13T15:23:57.863Z",
							"is_fixed_rate": true,
							"is_fee_paid_by_user": true,
							"valid_until": "2024-05-20T15:03:57.863Z",
							"type": "crypto2crypto",
							"product": "api",
							"success": "success"
			} */

		/* payment_status can be:
			waiting - waiting for the customer to send the payment. The initial status of each payment.
			confirming - the transaction is being processed on the blockchain. Appears when NOWPayments detect the funds from the user on the blockchain.
			confirmed - the process is confirmed by the blockchain. Customer’s funds have accumulated enough confirmations.
			sending - the funds are being sent to your personal wallet. We are in the process of sending the funds to you.
			partially_paid - it shows that the customer sent the less than the actual price. Appears when the funds have arrived in your wallet.
			finished - the funds have reached your personal address and the payment is finished.
			failed - the payment wasn't completed due to the error of some kind.
			refunded - the funds were refunded back to the user.
			expired - the user didn't send the funds to the specified address in the 24 hour time window.
			*/
	}

	public function gateway_NOWPayments_check_order_status($order_id) {
		$client = new Client();

		try {
			$response = $client->request('GET', $this->API_endpoint . 'payment/' . $order_id, [
				'headers'         => [
					'x-api-key' => $this->API_key,
				],
				'allow_redirects' => true,
			]);

			if ($response->getStatusCode() == 200) {
				return json_decode($response->getBody(), true);
			} else {
				return false;
			}
		} catch (RequestException $e) {
			echo 'Error: ' . $e->getMessage();
		}
	}


	// Calculates available payment currencies based on desired transaction amount
	public function get_available_payment_currencies($amt_USD) {

		$return_array = array();

		// 1. Get available currencies from NOWPayments
		$available_currencies = $this->gateway_NOWPayments_get_available_currencies();
		if (!$available_currencies) {
			return false;
		}

		// 2. Get currency details from NOWPayments
		$currency_details = $this->gateway_NOWPayments_get_available_currencies_detail();
		if (!$currency_details) {
			return false;
		}

		// 3. Get Binance ticker prices
		$binance_ticker_prices = $this->get_binance_ticker_price();

		// 4. Loop through available currencies and extract details
		foreach ($available_currencies as $currency) {

			$currency_id = $currency["currency"];
			$currency_min_amt = $currency["min_amount"];
			$currency_max_amt = $currency["max_amount"];

			// If currency_id is not in the currency_details array, skip to the next currency
			if (!in_array(strtoupper($currency_id), array_map('strtoupper', array_column($currency_details, 'code')))) {
				// echo "Currency not found in currency details array<br>";
				continue;
			}

			// Get relevant currency detail of the current currency in loop (Get only the first element of the array)
			$currency_detail = array_values(array_filter($currency_details, function ($currency) use ($currency_id) {
				return strtoupper($currency['code']) == strtoupper($currency_id);
			}))[0];

			// Skip if currency is not enabled
			if (!$currency_detail['enable']) {
				// echo "Currency not enabled<br>";
				continue;
			}

			// Relevant currency detail

			// If $currency_detail['ticker'] is not in the $currency_detail array, use $currency_detail['code'] instead
			$currency_ticker = $currency_detail['ticker'] ? $currency_detail['ticker'] : $currency_detail['code'];
			$currency_name = $currency_detail['name'];
			$currency_wallet_regex = $currency_detail['wallet_regex'];
			$currency_network = $currency_detail['network'];

			if ($currency_name == "Tether") {
				$currency_name = "USDT (" . $currency_network . ")";
			}


			// If currency is usdterc20 or usdttrc20 or usdtsol or usdtbsc, use the price of usd
			if (in_array($currency_id, array('usdterc20', 'usdttrc20', 'usdtsol', 'usdtbsc'))) {
				$binance_ticker_price = 1;
			} else {
				// If currency is not in the binance ticker prices array, skip to the next currency
				if (!in_array(strtoupper($currency_ticker) . 'USDT', array_map('strtoupper', array_column($binance_ticker_prices, 'symbol')))) {
					// echo "Currency not found in binance ticker prices array<br>";
					continue;
				}

				// Get relevant Binance ticker price of the current currency in loop
				$binance_ticker_price = array_values(array_filter($binance_ticker_prices, function ($currency) use ($currency_ticker) {
					return strtoupper($currency['symbol']) == strtoupper($currency_ticker) . 'USDT';
				}))[0]['price'];
			}

			// If the binance ticker price is not found or is 0, skip to the next currency
			if (!$binance_ticker_price || $binance_ticker_price == 0) {
				continue;
			}

			// Calculate the equivalent amount in the current currency
			$currency_amt = $amt_USD / $binance_ticker_price;

			// Add a 10% buffer to the currency amount
			$currency_amt = $currency_amt * 1.1;

			// die();

			// Check if the amount is within the min and max limits
			// If not, skip to the next currency
			if ($currency_amt < $currency_min_amt || $currency_amt > $currency_max_amt) {
				continue;
			} else {
				$return_array[] = array(
					'currency_id'           => $currency_id,
					'currency_name'         => $currency_name,
					'currency_ticker'       => $currency_ticker,
					'currency_est_amt'      => $currency_amt,
					'currency_wallet_regex' => $currency_wallet_regex,
					'currency_network'      => $currency_network,
				);
			}
		}

		// echo '<pre>' . var_export($return_array, true) . '</pre>'; die();
		// var_dump($return_array); die();

		// 5. Return the array of available currencies
		return $return_array;
	}


	// Creates a new payment order based on the selected currency
	public function create_payment_order($amt_USD, $currency_id, $order_id, $order_description) {

		$return_array = array();

		// 1. Get available currencies from NOWPayments
		$available_currencies = $this->gateway_NOWPayments_get_available_currencies();
		if (!$available_currencies) {
			return false;
		}

		// 2. Check if the selected currency is available. If not, return false
		$selected_currency = array_values(array_filter($available_currencies, function ($currency) use ($currency_id) {
			return $currency['currency'] === $currency_id;
		}))[0];
		if (!$selected_currency) {
			return false;
		}

		// 3. Create the payment order
		$payment_order = $this->gateway_NOWPayments_create_order($amt_USD, $currency_id, $order_id, $order_description);
		// var_dump($payment_order); die();
		if (!is_array($payment_order)) {
			return false;
		}

		// Calculates the expiration date of the payment order. It should be 30 minutes from created_at time, expiration_estimate_date or valid_until time, whichever is earlier
		$expiration_estimate_date = new DateTime($payment_order['expiration_estimate_date']);
		$valid_until_date = new DateTime($payment_order['valid_until']);
		$created_at_date = new DateTime($payment_order['created_at']);
		$updated_at_date = new DateTime($payment_order['updated_at']);
		$expiration_date = min($expiration_estimate_date, $valid_until_date, (new DateTime($payment_order['created_at']))->modify('+30 minutes'));
		// Expiration date should be in UTC timezone
		$expiration_date->setTimezone(new DateTimeZone('UTC'));

		$valid_until_unixtime = $valid_until_date->getTimestamp();
		$expiration_unixtime = $expiration_date->getTimestamp();
		$created_at_unixtime = $created_at_date->getTimestamp();
		$updated_at_unixtime = $updated_at_date->getTimestamp();

		// 4. Return the relevant payment order details
		$return_array = array(
			'payment_id'       => $payment_order['payment_id'],
			'payment_status'   => $payment_order['payment_status'],
			'pay_address'      => $payment_order['pay_address'],
			'price_amount'     => $payment_order['price_amount'],
			'price_currency'   => $payment_order['price_currency'],
			'pay_amount'       => $payment_order['pay_amount'], // Amount to pay in the selected currency (eg LTC)
			'amount_received'  => $payment_order['amount_received'],
			'pay_currency'     => $payment_order['pay_currency'],
			'outcome_currency' => isset($payment_order['outcome_currency']) ? $payment_order['outcome_currency'] : $payment_order['pay_currency'], // If outcome_currency is not in the payment_order array, use pay_currency instead
			'created_at'       => $created_at_unixtime,
			'updated_at'       => $updated_at_unixtime
		);

		$return_array['expiration_date'] = $expiration_unixtime;


		return $return_array;
	}


	// Checks the status of a payment order
	public function check_payment_order_status($order_id) {

		// Default txn_status and txn_status_text
		$txn_status = 'UNKNOWN';
		$txn_status_text = 'Your transaction status is unknown. Please contact support for assistance.';

		// Get payment order details from the database
		// `id`, `txn-hash`, `txn-hash_user`, `txn-status`, `txn-status_text`, `txn-amt_shiptokens`, `txn-amt_USD_cents`, `txn-time_created`, `txn-time_updated`, `txn-gateway`, `txn-gateway_response`, `txn-gateway_params`, `txn-comments`
		$query_payment_order = "SELECT
                                id, 
                                `txn-hash`, 
                                `txn-hash_user`, 
                                `txn-status`, 
                                `txn-status_text`, 
                                `txn-amt_shiptokens`, 
                                `txn-amt_USD_cents`, 
                                `txn-time_created`, 
                                `txn-time_updated`, 
                                `txn-gateway`, 
                                `txn-gateway_response`, 
                                `txn-gateway_params`,
								`txn-comments`
                                
                                FROM wallet_topups
                                WHERE `txn-hash` = :txn_hash";

		$query_params_payment_order = array(
			':txn_hash' => $order_id
		);

		try {
			$stmt_payment_order = $this->db->prepare($query_payment_order);
			$result_payment_order = $stmt_payment_order->execute($query_params_payment_order);
		} catch (PDOException $ex) {
			die("Failed to run query: " . $ex->getMessage());
		}

		$row_payment_order = $stmt_payment_order->fetch();

		// var_dump($row_payment_order); die();

		// If the payment order is not found in the database, return false
		if (!$row_payment_order) {
			return false;
		}

		// Update txn_status and txn_status_text based on db data, if not empty
		if (!empty($row_payment_order['txn-status'])) {
			$txn_status = $row_payment_order['txn-status'];
			$txn_status_text = $row_payment_order['txn-status_text'];
		}

		// Check if $row_payment_order['txn-gateway_params'] is empty
		if (empty($row_payment_order['txn-gateway_params'])) {
			// Default expiration date is 30 minutes from created_at time
			$expiration_date = (new DateTime($row_payment_order['txn-time_created']))->modify('+30 minutes');
			$expiration_unixtime = $expiration_date->getTimestamp();
			if ($expiration_unixtime < time()) {
				// If the expiration date is less than the current time, set the status to TIMEOUT_CANCELLED
				$txn_status = 'TIMEOUT_CANCELLED';
				$txn_status_text = 'Your transaction has expired. Please create a new purchase or contact support for assistance.';
			}
		} else {
			// Get payment params from the database
			$txn_gateway_params = json_decode($row_payment_order['txn-gateway_params'], true);

			// Get latest payment order details from gateway
			$latest_payment_order_status = $this->gateway_NOWPayments_check_order_status($txn_gateway_params['payment_id']);
			if (!$latest_payment_order_status) {
				return false;
			}

			// Merge the latest payment order status with the existing payment order params
			$latest_payment_order_status = array_merge($txn_gateway_params, $latest_payment_order_status);

			// var_dump($latest_payment_order_status); die();

			// Update the payment order status in the database under txn-gateway_params
			$query_update_gateway_params = "UPDATE wallet_topups
                                        SET `txn-gateway_params` = :txn_gateway_params
                                        WHERE `txn-hash` = :txn_hash";

			$query_params_update_gateway_params = array(
				':txn_hash'           => $order_id,
				':txn_gateway_params' => json_encode($latest_payment_order_status)
			);

			try {
				$stmt_update_gateway_params = $this->db->prepare($query_update_gateway_params);
				$result_update_gateway_params = $stmt_update_gateway_params->execute($query_params_update_gateway_params);
			} catch (PDOException $ex) {
				die("Failed to run query: " . $ex->getMessage());
			}
			if (!$result_update_gateway_params) {
				return false;
			}

			// Update status in database based on payment_status from $latest_payment_order_status
			/* payment_status can be:
			waiting - waiting for the customer to send the payment. The initial status of each payment.
			confirming - the transaction is being processed on the blockchain. Appears when NOWPayments detect the funds from the user on the blockchain.
			confirmed - the process is confirmed by the blockchain. Customer’s funds have accumulated enough confirmations.
			sending - the funds are being sent to your personal wallet. We are in the process of sending the funds to you.
			partially_paid - it shows that the customer sent the less than the actual price. Appears when the funds have arrived in your wallet.
			finished - the funds have reached your personal address and the payment is finished.
			failed - the payment wasn't completed due to the error of some kind.
			refunded - the funds were refunded back to the user.
			expired - the user didn't send the funds to the specified address in the 24 hour time window.
			*/
			$append_txn_gateway_response = 'Latest status from gateway: ' . $latest_payment_order_status['payment_status'];
			switch ($latest_payment_order_status['payment_status']) {
				case 'waiting':
				case 'confirming':
				case 'confirmed':
				case 'sending':
					$txn_status = 'PENDING_CONFIRMATION';
					$txn_status_text = 'Your transaction is currently pending confirmation. Please wait for the transaction to be confirmed.';
					break;
				case 'partially_paid':
					$txn_status = 'PENDING_PAYMENT';
					$txn_status_text = 'Your transaction is currently pending full payment. Please pay the remaining amount to complete the transaction.';
					break;
				case 'finished':
					$txn_status = 'PAYMENT_COMPLETED';
					$txn_status_text = 'Your transaction has been completed successfully.';
					break;
				case 'failed':
				case 'refunded':
					$txn_status = 'FAILED_PAYMENT';
					$txn_status_text = 'Your transaction has failed. Please create a new purchase or contact support for assistance.';
					break;
				case 'expired':
					$txn_status = 'TIMEOUT_CANCELLED';
					$txn_status_text = 'Your transaction has expired. Please create a new purchase or contact support for assistance.';
					break;
				default:
					$txn_status = 'UNKNOWN';
					$txn_status_text = 'Your transaction status is unknown. Please contact support for assistance.';
					break;
			}


			// Calculates the expiration date of the payment order. It should be 30 minutes from created_at time, expiration_estimate_date or valid_until time, whichever is earlier
			$created_at_date = new DateTime($row_payment_order['txn-time_created']);
			// If expiration_estimate_date and valid_until are not in the latest_payment_order_status array, expiration_estimate_date and valid_until should equal to created_at time + 30mins instead
			if (!array_key_exists('expiration_estimate_date', $latest_payment_order_status) || !array_key_exists('valid_until', $latest_payment_order_status)) {
				$expiration_estimate_date = (new DateTime($row_payment_order['txn-time_created']))->modify('+30 minutes');
				$expiration_estimate_date = (new DateTime($row_payment_order['txn-time_created']))->modify('+30 minutes');
				$valid_until_date = (new DateTime($row_payment_order['txn-time_created']))->modify('+30 minutes');
			} else {
				$expiration_estimate_date = new DateTime($latest_payment_order_status['expiration_estimate_date']);
				$valid_until_date = new DateTime($latest_payment_order_status['valid_until']);
			}

			$updated_at_date = new DateTime($row_payment_order['txn_balance_last_updated_time']);
			$expiration_date = DateTime::createFromFormat('U', min(
				$expiration_estimate_date->getTimestamp(),
				$valid_until_date->getTimestamp(),
				(new DateTime($row_payment_order['txn-time_created']))->modify('+30 minutes')->getTimestamp()
			));
			$valid_until_unixtime = $valid_until_date->getTimestamp();
			$expiration_unixtime = $expiration_date->getTimestamp();
			$created_at_unixtime = $created_at_date->getTimestamp();
			$updated_at_unixtime = $updated_at_date->getTimestamp();

			// If txn_balance_latest_status is FAILED_PAYMENT or USER_CANCELLED, do not update the status
			if ($txn_status == 'FAILED_PAYMENT' || $txn_status == 'USER_CANCELLED') {
				$txn_status = $row_payment_order['txn_status'];
				$txn_status_text = $row_payment_order['txn_status_text'];
			} elseif ($txn_status != 'PAYMENT_COMPLETED' && $txn_status != 'PENDING_CONFIRMATION' && time() > $expiration_unixtime) {
				// If txn_balance_latest_status is not PAYMENT_COMPLETED or PENDING_CONFIRMATION, and the current time is greater than the expiration date, update the status to TIMEOUT_CANCELLED
				$txn_status = 'TIMEOUT_CANCELLED';
				$txn_status_text = 'Your transaction has expired. Please create a new purchase or contact support for assistance.';
			}
		}

		// Update the payment order status in the database under txn_status and txn_status_text
		$query_update_payment_order = "UPDATE wallet_topups
                                        SET `txn-status` = :txn_status,
                                            `txn-status_text` = :txn_status_text
                                        WHERE `txn-hash` = :txn_hash";

		$query_params_update_payment_order = array(
			':txn_hash'               => $order_id,
			':txn_status'      => $txn_status,
			':txn_status_text' => $txn_status_text
		);

		try {
			$stmt_update_payment_order = $this->db->prepare($query_update_payment_order);
			$result_payment_order = $stmt_update_payment_order->execute($query_params_update_payment_order);
		} catch (PDOException $ex) {
			die("Failed to run query: " . $ex->getMessage());
		}
		if (!$result_payment_order) {
			return false;
		}


		// Return the relevant payment order details
		$return_array = array(
			'payment_id'          => $txn_gateway_params['payment_id'],
			'payment_status'      => $txn_status,
			'payment_status_text' => $txn_status_text,
			'price_amount'        => $txn_gateway_params['price_amount'],
			'price_currency'      => $txn_gateway_params['price_currency'],
			'pay_amount'          => $txn_gateway_params['pay_amount'], // Amount to pay in the selected currency (eg LTC)
			'amount_received'     => isset($txn_gateway_params['amount_received']) ? $txn_gateway_params['amount_received'] : 0,
			'pay_currency'        => $txn_gateway_params['pay_currency'],
			'outcome_currency'    => $txn_gateway_params['outcome_currency'] ? $txn_gateway_params['outcome_currency'] : $txn_gateway_params['pay_currency'], // If outcome_currency is not in the payment_order array, use pay_currency instead
			'created_at'          => $created_at_unixtime,
			'updated_at'          => $updated_at_unixtime,
		);

		$return_array['expiration_date'] = $expiration_unixtime;
		$return_array['txn_balance_gems_amt'] = $row_payment_order['txn_balance_gems_amt'];
		$return_array['txn_balance_usd_amt'] = $row_payment_order['txn_balance_usd_amt'];
		$return_array['txn_balance_gateway'] = $row_payment_order['txn_balance_gateway'];


		return $return_array;
	}


	// Checks status of ALL pending orders
	public function check_all_pending_orders() {

		// Get all pending orders from the database
		$query_all_pending_orders = "SELECT
								id, 
								`txn-hash`, 
								`txn-hash_user`, 
								`txn-status`, 
								`txn-status_text`, 
								`txn-amt_shiptokens`, 
								`txn-amt_USD_cents`, 
								`txn-time_created`, 
								`txn-time_updated`, 
								`txn-gateway`, 
								`txn-gateway_response`, 
								`txn-gateway_params` 
								
								FROM wallet_topups 	
								WHERE `txn-status` = 'PENDING_CONFIRMATION' OR `txn-status` = 'PENDING_PAYMENT' OR `txn-status` = 'PENDING'
								AND `txn-gateway` = 'crypto_nowpayments'";

		try {
			$stmt_all_pending_orders = $this->db->prepare($query_all_pending_orders);
			$result_all_pending_orders = $stmt_all_pending_orders->execute();
		} catch (PDOException $ex) {
			die("Failed to run query: " . $ex->getMessage());
		}

		$rows_all_pending_orders = $stmt_all_pending_orders->fetchAll();

		// If there are no pending orders, return false
		if (!$rows_all_pending_orders) {
			return false;
		}

		// Loop through all pending orders and check the status of each order
		foreach ($rows_all_pending_orders as $row) {
			// Call check_payment_order_status function for each order
			$this->check_payment_order_status($row['txn-hash']);
		}
		return true;
	}
}
